import { command } from 'yargs';
import _get from 'lodash/fp/get';
import { readJsonSync, outputFile, existsSync, copySync, outputJSON, pathExistsSync, copy, ensureDir, removeSync, readFileSync, readJSONSync, outputJSONSync } from 'fs-extra';
import { get, set } from 'env-dot-prop';
import humanize from 'humanize-string';
import titleize from 'titleize';
import { realpathSync } from 'fs';
import path$1__default, { parse, join, resolve, delimiter, isAbsolute, relative, extname, normalize, dirname } from 'path';
import { sync } from 'resolve';
import _merge from 'lodash/fp/merge';
import _omit from 'lodash/fp/omit';
import { loadFrom, load, finds } from 'load-cfg';
import detectPort from 'detect-port';
import _isFunction from 'lodash/fp/isFunction';
import logger__default, { error, warn } from 'signale';
import { assign, Machine, interpret } from 'xstate';
import findUp from 'find-up';
import { compiled } from 'docz-utils/lib/fs';
import { format } from 'docz-utils/lib/format';
import spawn$1 from 'cross-spawn';
import waitOn from 'wait-on';
import get$1 from 'lodash/get';
import chokidar from 'chokidar';
import getPkgRepo from 'get-pkg-repo';
import _assoc from 'lodash/fp/assoc';
import glob from 'fast-glob';
import sh from 'shelljs';
import equal from 'fast-deep-equal';
import _isString from 'lodash/fp/isString';
import _isRegExp from 'lodash/fp/isRegExp';
import { __rest } from 'tslib';
import { getParsedData, headingsFromAst, parseMdx } from 'docz-utils/lib/mdast';
import minimatch from 'minimatch';
import { createHash } from 'crypto';
import slugify from '@sindresorhus/slugify';
import _propEq from 'lodash/fp/propEq';
import actualNameHandler from 'react-docgen-actual-name-handler';
import { defaultHandlers, parse as parse$1 } from 'react-docgen';
import _entries from 'lodash/fp/entries';
import _contains from 'lodash/fp/contains';
import _prop from 'lodash/fp/prop';
import _isEmpty from 'lodash/fp/isEmpty';
import { withCustomConfig } from 'react-docgen-typescript';
import ts from 'typescript';

const ensureSlash = (filepath, needsSlash) => {
  const hasSlash = filepath.endsWith('/');

  if (hasSlash && !needsSlash) {
    return filepath.substr(filepath, filepath.length - 1);
  } else if (!hasSlash && needsSlash) {
    return `${filepath}/`;
  } else {
    return filepath;
  }
};
const root = realpathSync(process.cwd());
const IS_DOCZ_PROJECT = parse(root).base === '.docz';
const resolveApp = to => resolve(root, IS_DOCZ_PROJECT ? '../' : './', to);
const checkIsDoczProject = config => {
  return parse(config.root || root).base === '.docz';
};
const getRootDir = config => {
  const isDoczProject = checkIsDoczProject(config);
  return isDoczProject ? resolve(root, '../') : root;
};
const getThemesDir = config => {
  // resolve normalizes the new path and removes trailing slashes
  return resolve(join(getRootDir(config), config.themesDir));
};
const templates = join(sync('docz-core'), '../templates');
const servedPath = base => ensureSlash(base, true);
const docz = resolveApp('.docz');
const cache = resolve(docz, '.cache/');
const app = resolve(docz, 'app/');
const appPackageJson = resolveApp('package.json');
const appTsConfig = resolveApp('tsconfig.json');
const gatsbyConfig = resolveApp('gatsby-config.js');
const gatsbyBrowser = resolveApp('gatsby-browser.js');
const gatsbyNode = resolveApp('gatsby-node.js');
const gatsbySSR = resolveApp('gatsby-ssr.js');
const getDist = dest => join(root, dest);
const distPublic = dest => join(dest, 'public/');
const importsJs = resolve(app, 'imports.js');
const rootJs = resolve(app, 'root.jsx');
const indexJs = resolve(app, 'index.jsx');
const indexHtml = resolve(app, 'index.html');
const db = resolve(app, 'db.json');

var paths = /*#__PURE__*/Object.freeze({
  ensureSlash: ensureSlash,
  root: root,
  resolveApp: resolveApp,
  checkIsDoczProject: checkIsDoczProject,
  getRootDir: getRootDir,
  getThemesDir: getThemesDir,
  templates: templates,
  servedPath: servedPath,
  docz: docz,
  cache: cache,
  app: app,
  appPackageJson: appPackageJson,
  appTsConfig: appTsConfig,
  gatsbyConfig: gatsbyConfig,
  gatsbyBrowser: gatsbyBrowser,
  gatsbyNode: gatsbyNode,
  gatsbySSR: gatsbySSR,
  getDist: getDist,
  distPublic: distPublic,
  importsJs: importsJs,
  rootJs: rootJs,
  indexJs: indexJs,
  indexHtml: indexHtml,
  db: db
});

const pReduce = (iterable, reducer, initialValue) => new Promise((resolve, reject) => {
  const iterator = iterable[Symbol.iterator]();
  let index = 0;

  const next = async total => {
    const element = iterator.next();

    if (element.done) {
      resolve(total);
      return;
    }

    try {
      const value = await Promise.all([total, element.value]);
      next(reducer(value[0], value[1], index++));
    } catch (error) {
      reject(error);
    }
  };

  next(initialValue);
});

class Plugin {
  constructor(p) {
    this.setConfig = p.setConfig;
    this.onCreateWebpackConfig = p.onCreateWebpackConfig;
    this.onCreateBabelConfig = p.onCreateBabelConfig;
    this.modifyFiles = p.modifyFiles;
    this.onCreateDevServer = p.onCreateDevServer;
    this.onPreBuild = p.onPreBuild;
    this.onPostBuild = p.onPostBuild;
  }

  static runPluginsMethod(plugins) {
    return (method, ...args) => {
      if (plugins && plugins.length > 0) {
        for (const plugin of plugins) {
          const fn = _get(method, plugin);

          if (_isFunction(fn)) {
            fn(...args);
          }
        }
      }
    };
  }

  static propsOfPlugins(plugins) {
    return prop => plugins && plugins.length > 0 ? plugins.map(p => _get(prop, p)).filter(Boolean) : [];
  }

  static reduceFromPlugins(plugins) {
    return (method, initial, ...args) => {
      return [...(plugins || [])].reduce((obj, plugin) => {
        const fn = _get(method, plugin);

        return fn && _isFunction(fn) ? fn(obj, ...args) : obj;
      }, initial);
    };
  }

  static reduceFromPluginsAsync(plugins) {
    return (method, initial, ...args) => {
      return pReduce([...(plugins || [])], (obj, plugin) => {
        const fn = _get(method, plugin);

        return Promise.resolve(fn && _isFunction(fn) ? fn(obj, ...args) : obj);
      }, initial);
    };
  }

}
function createPlugin(factory) {
  return new Plugin(factory);
}

const toOmit = ['_', '$0', 'version', 'help'];
const doczRcBaseConfig = {
  themeConfig: {},
  src: './',
  gatsbyRoot: null,
  themesDir: 'src',
  mdxExtensions: ['.md', '.mdx'],
  docgenConfig: {},
  menu: [],
  plugins: [],
  mdPlugins: [],
  hastPlugins: [],
  ignore: [/readme.md/i, /changelog.md/i, /code_of_conduct.md/i, /contributing.md/i, /license.md/i],
  filterComponents: files => files.filter(filepath => {
    const isTestFile = /\.(test|spec)\.(js|jsx|ts|tsx)$/.test(filepath);

    if (isTestFile) {
      return false;
    }

    const startsWithCapitalLetter = /\/([A-Z]\w*)\.(js|jsx|ts|tsx)$/.test(filepath);
    const isCalledIndex = /\/index\.(js|jsx|ts|tsx)$/.test(filepath);
    const hasJsxOrTsxExtension = /.(jsx|tsx)$/.test(filepath);
    return startsWithCapitalLetter || isCalledIndex || hasJsxOrTsxExtension;
  })
};
const getBaseConfig = (argv, custom) => {
  const initial = _omit(toOmit, argv);

  const base = Object.assign({}, doczRcBaseConfig, initial, {
    paths
  });
  return _merge(base, custom);
};
const parseConfig = async (argv, custom) => {
  const port = await detectPort(argv.port);
  const defaultConfig = getBaseConfig(argv, Object.assign({
    port
  }, custom));
  const config = argv.config ? loadFrom(join(docz, 'doczrc.js'), defaultConfig) : load('docz', defaultConfig);
  const reduceAsync = Plugin.reduceFromPluginsAsync(config.plugins);
  return reduceAsync('setConfig', config);
};

const getEnv = (val, defaultValue = null) => get(val, defaultValue, {
  parse: true
});

const getInitialTitle = pkg => {
  const name = _get('name', pkg) || 'MyDoc';
  return titleize(humanize(name.replace(/^@.*\//, '')));
};

const getInitialDescription = pkg => _get('description', pkg) || 'My awesome app using docz';

const setArgs = yargs => {
  const pkg = readJsonSync(appPackageJson, {
    throws: false
  });
  return yargs.option('root', {
    type: 'string',
    default: getEnv('docz.root', root)
  }).option('base', {
    type: 'string',
    default: getEnv('docz.base', '/')
  }).option('source', {
    alias: 'src',
    type: 'string',
    default: getEnv('docz.source', doczRcBaseConfig.src)
  }).option('gatsbyRoot', {
    type: 'string',
    default: getEnv('docz.gatsbyRoot', doczRcBaseConfig.gatsbyRoot)
  }).option('files', {
    type: 'string',
    default: getEnv('docz.files', '**/*.{md,markdown,mdx}')
  }).option('ignore', {
    type: 'array',
    default: getEnv('docz.ignore', [])
  }).option('public', {
    type: 'string',
    default: getEnv('docz.public', '/public')
  }).option('dest', {
    alias: 'd',
    type: 'string',
    default: getEnv('docz.dest', '.docz/dist')
  }).option('editBranch', {
    alias: 'eb',
    type: 'string',
    default: getEnv('docz.edit.branch', 'master')
  }).option('config', {
    type: 'string',
    default: getEnv('docz.config', '')
  }).option('title', {
    type: 'string',
    default: getEnv('docz.title', getInitialTitle(pkg))
  }).option('description', {
    type: 'string',
    default: getEnv('docz.description', getInitialDescription(pkg))
  }).option('typescript', {
    alias: 'ts',
    type: 'boolean',
    default: getEnv('docz.typescript', false)
  }).option('propsParser', {
    type: 'boolean',
    default: getEnv('docz.props.parser', true)
  }).option('debug', {
    type: 'boolean',
    default: getEnv('docz.debug', false)
  }).option('host', {
    type: 'string',
    default: getEnv('docz.host', 'localhost')
  }).option('port', {
    alias: 'p',
    type: 'number',
    default: getEnv('docz.port', 3000)
  }).option('native', {
    type: 'boolean',
    default: getEnv('docz.native', false)
  }).option('separator', {
    type: 'string',
    default: getEnv('docz.separator', '-')
  }).option('openBrowser', {
    alias: ['o', 'open'],
    describe: 'auto open browser in dev mode',
    type: 'boolean',
    default: null
  });
};

const populateNodePath = () => {
  // We support resolving modules according to `NODE_PATH`.
  // It works similar to `NODE_PATH` in Node itself:
  // https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders
  // Note that unlike in Node, only *relative* paths from `NODE_PATH` are honored.
  // Otherwise, we risk importing Node.js core modules into an app instead of Webpack shims.
  // https://github.com/facebook/create-react-app/issues/1023#issuecomment-265344421
  // We also resolve them to make sure all tools using them work consistently.
  set('node.path', get('node.path', '').split(delimiter).filter(folder => folder && !isAbsolute(folder)).map(folder => resolve(root, folder)).join(delimiter));
};

const configDotEnv = () => {
  const NODE_ENV = get('node.env');
  const dotenv = resolveApp('.env');
  const dotenvFiles = [`${dotenv}.${NODE_ENV}.local`, `${dotenv}.${NODE_ENV}`, // Don't include `.env.local` for `test` environment
  // since normally you expect tests to produce the same
  // results for everyone
  NODE_ENV !== 'test' && `${dotenv}.local`, dotenv]; // Load environment variables from .env* files. Suppress warnings using silent
  // if this file is missing. dotenv will never modify any environment variables
  // that have already been set.  Variable expansion is supported in .env files.
  // https://github.com/motdotla/dotenv

  dotenvFiles.filter(Boolean).forEach(dotenvFile => {
    require('dotenv').config({
      path: dotenvFile
    });
  });
};

const setEnv = env => {
  set('babel.env', env);
  set('node.env', env);
  configDotEnv();
  populateNodePath();
};

class Bundler {
  constructor(params) {
    const {
      args,
      server,
      build
    } = params;
    this.args = args;
    this.server = server;
    this.builder = build;
  }

  async createApp() {
    return this.server();
  }

  async build() {
    const dist = getDist(this.args.dest);
    const root = getRootDir(this.args);

    if (root === resolve(dist)) {
      logger__default.fatal(new Error('Unexpected option: "dest" cannot be set to the current working directory.'));
      process.exit(1);
    }

    await this.builder(this.args, dist);
  }

}

const fromTemplates = file => {
  return join(templates, file);
};
const outputFileFromTemplate = async (templatePath, outputPath, templateProps, compileProps) => {
  const filepath = fromTemplates(templatePath);
  const template = await compiled(filepath, compileProps || {
    minimize: false
  });
  const file = template(templateProps || {});
  const raw = await format(file);
  await outputFile(outputPath, raw);
};

const copyDoczRc = configPath => {
  const sourceDoczRc = configPath ? join(root, configPath) : join(root, 'doczrc.js');
  const hasDoczRc = existsSync(sourceDoczRc);
  if (!hasDoczRc) return;
  const destinationDoczRc = join(docz, 'doczrc.js');

  try {
    copySync(sourceDoczRc, destinationDoczRc);
  } catch (err) {}
};

const copyAndModifyPkgJson = async ctx => {
  const movePath = join(docz, 'package.json'); // const pkg = await fs.readJSON(filepath, { throws: false })

  const newPkg = Object.assign({
    name: 'docz-app',
    license: 'MIT',
    dependencies: {
      gatsby: 'just-to-fool-cli-never-installed'
    },
    scripts: {
      dev: 'gatsby develop',
      build: 'gatsby build',
      serve: 'gatsby serve'
    }
  }, ctx.isDoczRepo && {
    private: true,
    workspaces: ['../../../core/**', '../../../other-packages/**']
  });
  await outputJSON(movePath, newPkg, {
    spaces: 2
  });
};

const writeEslintRc = async () => {
  const possibleFilenames = ['.eslintrc.js', '.eslintrc.yaml', '.eslintrc.yml', '.eslintrc.json', '.eslintrc'];

  for (const filename of possibleFilenames) {
    const filepath = join(root, filename);
    const dest = join(docz, filename);

    if (pathExistsSync(filepath)) {
      await copy(filepath, dest);
      return;
    }
  }
};

const copyDotEnv = () => {
  const filename = '.env';
  const filepath = join(root, filename);
  const dest = join(docz, filename);

  if (pathExistsSync(filepath)) {
    copySync(filepath, dest);
  }
};

const copyEslintIgnore = async () => {
  const filename = '.eslintignore';
  const filepath = join(root, filename);
  const dest = join(docz, filename);

  if (pathExistsSync(filepath)) {
    await copy(filepath, dest);
  }
};

const writeNotFound = async () => {
  const outputPath = join(docz, 'src/pages/404.js');
  await outputFileFromTemplate('404.tpl.js', outputPath, {});
};

const writeGatsbyConfig = async ({
  args,
  isDoczRepo
}) => {
  const outputPath = join(docz, 'gatsby-config.js');

  const config = _omit(['plugins'], args);

  const newConfig = Object.assign({}, config, {
    root: docz
  });
  await outputFileFromTemplate('gatsby-config.tpl.js', outputPath, {
    isDoczRepo,
    config: newConfig,
    opts: JSON.stringify(newConfig)
  });
};

const writeGatsbyConfigNode = async () => {
  const outputPath = join(docz, 'gatsby-node.js');
  await outputFileFromTemplate('gatsby-node.tpl.js', outputPath);
};

const copyGatsbyConfigFile = async (from, to) => {
  const filepath = join(root, from);
  const dest = join(docz, to);

  if (pathExistsSync(filepath)) {
    await copy(filepath, dest);
  }
};

const writeGatsbyConfigCustom = async () => copyGatsbyConfigFile('gatsby-config.js', 'gatsby-config.custom.js');

const writeGatsbyNodeCustom = async () => copyGatsbyConfigFile('gatsby-node.js', 'gatsby-node.custom.js');

const writeGatsbySSR = async () => copyGatsbyConfigFile('gatsby-ssr.js', 'gatsby-ssr.js');

const writeGatsbyBrowser = async () => copyGatsbyConfigFile('gatsby-browser.js', 'gatsby-browser.js');

const createResources = async ctx => {
  try {
    copyDoczRc(ctx.args.config);
    copyDotEnv();
    await copyAndModifyPkgJson(ctx);
    await writeEslintRc();
    await copyEslintIgnore();
    await writeNotFound();
    await writeGatsbyConfig(ctx);
    await writeGatsbyConfigNode();
    await writeGatsbyConfigCustom();
    await writeGatsbyNodeCustom();
    await writeGatsbyBrowser();
    await writeGatsbySSR();
  } catch (err) {
    console.error(err);
  }
};

const ensureDirs = async () => {
  await ensureDir(docz);
  return await ensureDir(join(docz, 'src/pages'));
};

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var chalk = require('chalk');

var execSync = require('child_process').execSync;

var spawn = require('cross-spawn');

var opn = require('opn'); // https://github.com/sindresorhus/opn#app


var OSX_CHROME = 'google chrome';
const Actions = Object.freeze({
  NONE: 0,
  BROWSER: 1,
  SCRIPT: 2
});

function getBrowserEnv() {
  // Attempt to honor this environment variable.
  // It is specific to the operating system.
  // See https://github.com/sindresorhus/opn#app for documentation.
  const value = process.env.BROWSER;
  let action;

  if (!value) {
    // Default.
    action = Actions.BROWSER;
  } else if (value.toLowerCase().endsWith('.js')) {
    action = Actions.SCRIPT;
  } else if (value.toLowerCase() === 'none') {
    action = Actions.NONE;
  } else {
    action = Actions.BROWSER;
  }

  return {
    action,
    value
  };
}

function executeNodeScript(scriptPath, url) {
  const extraArgs = process.argv.slice(2);
  const child = spawn('node', [scriptPath, ...extraArgs, url], {
    stdio: 'inherit'
  });
  child.on('close', code => {
    if (code !== 0) {
      console.log();
      console.log(chalk.red('The script specified as BROWSER environment variable failed.'));
      console.log(chalk.cyan(scriptPath) + ' exited with code ' + code + '.');
      console.log();
      return;
    }
  });
  return true;
}

function startBrowserProcess(browser, url) {
  // If we're on OS X, the user hasn't specifically
  // requested a different browser, we can try opening
  // Chrome with AppleScript. This lets us reuse an
  // existing tab when possible instead of creating a new one.
  const shouldTryOpenChromeWithAppleScript = process.platform === 'darwin' && (typeof browser !== 'string' || browser === OSX_CHROME);

  if (shouldTryOpenChromeWithAppleScript) {
    try {
      // Try our best to reuse existing tab
      // on OS X Google Chrome with AppleScript
      execSync('ps cax | grep "Google Chrome"');
      execSync('osascript openChrome.applescript "' + encodeURI(url) + '"', {
        cwd: __dirname,
        stdio: 'ignore'
      });
      return true;
    } catch (err) {// Ignore errors.
    }
  } // Another special case: on OS X, check if BROWSER has been set to "open".
  // In this case, instead of passing `open` to `opn` (which won't work),
  // just ignore it (thus ensuring the intended behavior, i.e. opening the system browser):
  // https://github.com/facebook/create-react-app/pull/1690#issuecomment-283518768


  if (process.platform === 'darwin' && browser === 'open') {
    browser = undefined;
  } // Fallback to opn
  // (It will always open new tab)


  try {
    var options = {
      app: browser,
      wait: false
    };
    opn(url, options).catch(() => {}); // Prevent `unhandledRejection` error.

    return true;
  } catch (err) {
    return false;
  }
}
/**
 * Reads the BROWSER environment variable and decides what to do with it. Returns
 * true if it opened a browser or ran a node.js script, otherwise false.
 */


function openBrowser(url) {
  const {
    action,
    value
  } = getBrowserEnv();

  switch (action) {
    case Actions.NONE:
      // Special case: BROWSER="none" will prevent opening completely.
      return false;

    case Actions.SCRIPT:
      return executeNodeScript(value, url);

    case Actions.BROWSER:
      return startBrowserProcess(value, url);

    default:
      throw new Error('Not implemented.');
  }
}

const findRootPath = async () => {
  let repoRootPath = path$1__default.join(docz, '../');

  try {
    const foundRootPath = await findUp(async directory => {
      const hasGatsby = await findUp.exists(path$1__default.join(directory, 'node_modules', 'gatsby'));
      return hasGatsby ? directory : '';
    }, {
      type: 'directory'
    });

    if (typeof foundRootPath === 'string') {
      repoRootPath = foundRootPath;
    }
  } catch (err) {
    console.log(`Failed to find root folder ${err.message} \n Assuming it is ${repoRootPath}`);
  }

  return repoRootPath;
};
const execDevCommand = async ({
  args
}) => {
  // For monorepos that install dependencies higher in the fs tree
  const repoRootPath = get$1(args, 'repoRootPath', (await findRootPath()));
  const gatsbyPath = path$1__default.join(repoRootPath, 'node_modules/.bin/gatsby'); // const cliArgs = process.argv.slice(3)

  spawn$1(gatsbyPath, ['develop', '--host', `${args.host}`, '--port', `${args.port}`], {
    stdio: 'inherit',
    cwd: docz
  });
  const url = `http://${args.host}:${args.port}`;
  console.log();
  console.log('Building app');
  await waitOn({
    resources: [url],
    timeout: 30000
  });
  console.log();
  console.log('App ready on ' + url);

  if (args.open !== null && Boolean(args.open) === false) {
    return;
  }

  openBrowser(url);
};

const installDeps = async () => {
  // No need to install dependencies
  return;
};

const parseRepo = () => {
  try {
    const pkg = readJsonSync(appPackageJson);
    return getPkgRepo(pkg);
  } catch (err) {
    return null;
  }
};
const getRepoUrl = () => {
  const repo = parseRepo();
  return repo && (repo.browsetemplate && repo.browsetemplate.replace('{domain}', repo.domain).replace('{user}', repo.user).replace('{project}', repo.project).replace('{/tree/committish}', '') || repo.browse && repo.browse());
};

const getBitBucketPath = (branch, relative) => {
  const querystring = `?mode=edit&spa=0&at=${branch}&fileviewer=file-view-default`;
  const filepath = join(`/src/${branch}`, relative, `{{filepath}}`);
  return `${filepath}${querystring}`;
};

const getTree = (repo, branch, relative) => {
  const defaultPath = join(`/edit/${branch}`, relative, `{{filepath}}`);
  const bitBucketPath = getBitBucketPath(branch, relative);
  if (repo && repo.type === 'bitbucket') return bitBucketPath;
  return defaultPath;
};

const getRepoEditUrl = config => {
  try {
    const repo = parseRepo();
    const gitDir = findUp.sync('.git', {
      type: 'directory'
    });
    if (!gitDir) return null;
    const project = parse(gitDir).dir;
    const root = join(getRootDir(config), config.src);
    const relative$1 = relative(project, root);
    const tree = getTree(repo, config.editBranch, relative$1);
    return repo && repo.browsetemplate && repo.browsetemplate.replace('{domain}', repo.domain).replace('{user}', repo.user).replace('{project}', repo.project).replace('{/tree/committish}', tree);
  } catch (err) {
    console.log(err);
    return null;
  }
};

const getInitialConfig = config => {
  const pkg = readJsonSync(appPackageJson, {
    throws: false
  });
  const repoUrl = getRepoUrl();
  return {
    title: config.title,
    description: config.description,
    menu: config.menu,
    version: get$1(pkg, 'version'),
    repository: repoUrl,
    native: config.native,
    themeConfig: config.themeConfig,
    separator: config.separator
  };
};

const update = async (params, initial, {
  config
}) => {
  const pathToConfig = join(docz, 'doczrc.js');
  const next = config ? loadFrom(pathToConfig, initial, true, true) : load('docz', initial, true, true);
  params.setState('config', next);
};

const WATCH_IGNORE = /(((^|[\/\\])\.((?!docz)(.+)))|(node_modules))/;
const createWatcher = (glob, config) => {
  const ignored = config.watchIgnore || WATCH_IGNORE;
  const watcher = chokidar.watch(glob, {
    ignored,
    cwd: root,
    persistent: true
  });
  watcher.setMaxListeners(Infinity);
  return watcher;
};
const state = (config, dev) => {
  const glob = config.config || finds('docz');
  const initial = getInitialConfig(config);
  const watcher = createWatcher(glob, config);
  return {
    id: 'config',
    start: async params => {
      const fn = async () => update(params, initial, config);

      await update(params, initial, config);

      if (dev) {
        watcher.on('add', fn);
        watcher.on('change', fn);
        watcher.on('unlink', fn);
      }
    },
    close: () => {
      watcher.close();
    }
  };
};

/**
 * Maps a given relative 'filepath' from 'themesDir/...' to 'src/...'
 */

const replaceThemesDir = (filepath, args) => {
  // Make the path to a given relative`filepath` relative to themesDir:
  const rawFilePath = relative(getThemesDir(args), resolve(root, filepath)); // => e.g. '/gatsby-theme-docz/**/index.tsx'
  // Prefix with 'src':

  return join('src', rawFilePath); // => 'src/gatsby-theme-docz/**/index.tsx'
};

const watchGatsbyThemeFiles = args => {
  const watcher = createWatcher(join(args.themesDir, 'gatsby-theme-**/**/*'), args);

  const copy = filepath => {
    const src = resolve(root, filepath);
    const dest = resolve(docz, replaceThemesDir(filepath, args));
    copySync(src, dest);
  };

  const remove = filepath => {
    removeSync(resolve(docz, filepath));
  };

  watcher.on('add', copy).on('addDir', copy).on('change', copy).on('unlink', remove).on('unlinkDir', remove);
  return () => watcher.close();
};

const createWatch = args => (glob, src, custom) => {
  const watcher = createWatcher(glob, args);
  const srcPath = join(root, src);
  const destPath = join(docz, custom ? src.replace('.js', '.custom.js') : src);

  const copyFile = () => copySync(srcPath, destPath);

  const deleteFile = () => removeSync(destPath);

  watcher.on('add', copyFile).on('change', copyFile).on('unlink', deleteFile);
  return () => watcher.close();
};

const watchDoczRc = args => {
  const watcher = createWatcher(join(root, args.config ? args.config : 'doczrc.js'), args);

  const copy = filepath => {
    const src = resolve(root, filepath);
    const dest = resolve(docz, 'doczrc.js');
    copySync(src, dest);
  };

  const remove = () => {
    removeSync(resolve(docz, 'doczrc.js'));
  };

  watcher.on('add', copy).on('change', copy).on('unlink', remove);
  return () => watcher.close();
};

const watchFiles = ({
  args
}) => () => {
  const watch = createWatch(args);
  const doczrc = watchDoczRc(args);
  const gatsbyBrowser$1 = watch(gatsbyBrowser, 'gatsby-browser.js');
  const gatsbyNode$1 = watch(gatsbyNode, 'gatsby-node.js');
  const gatsbySSR$1 = watch(gatsbySSR, 'gatsby-ssr.js');
  const gatsbyConfig$1 = watch(gatsbyConfig, 'gatsby-config.js', true);
  const themeFilesWatcher = watchGatsbyThemeFiles(args);
  return () => {
    doczrc();
    gatsbyConfig$1();
    gatsbyBrowser$1();
    gatsbyNode$1();
    gatsbySSR$1();
    themeFilesWatcher();
  };
};



var services = /*#__PURE__*/Object.freeze({
  createResources: createResources,
  ensureDirs: ensureDirs,
  execDevCommand: execDevCommand,
  installDeps: installDeps,
  watchFiles: watchFiles
});

const ensureFile = (filename, toDelete) => {
  const ghost = resolve(docz, toDelete || filename);
  const original = resolve(root, filename);

  if (pathExistsSync(ghost) && !pathExistsSync(original)) {
    removeSync(ghost);
  }
};

const ensureFiles = ({
  args
}) => {
  const appPath = join(root, args.themesDir);
  const themeNames = glob.sync('gatsby-theme-**', {
    cwd: appPath,
    onlyDirectories: true
  });
  themeNames.forEach(themeName => {
    copySync(join(appPath, themeName), join(docz, 'src', themeName));
  });
  copyDoczRc(args.config);
  ensureFile('gatsby-browser.js');
  ensureFile('gatsby-ssr.js');
  ensureFile('gatsby-node.js');
  ensureFile('gatsby-config.js', 'gatsby-config.custom.js');
  const publicPath = join(docz, '..', args.public);

  if (existsSync(publicPath)) {
    const destinationPath = join(docz, 'static', args.public);

    try {
      copySync(publicPath, destinationPath);
    } catch (err) {
      console.log(`Failed to copy static assets from ${publicPath} to ${destinationPath} : ${err.message}`);
    }
  }
};
const getIsFirstInstall = () => {
  return !sh.test('-e', join(docz, 'package.json'));
};
const getIsDoczRepo = () => {
  return sh.test('-e', join(root, '../../core'));
};
const assignFirstInstall = assign(ctx => {
  const firstInstall = getIsFirstInstall();
  return _assoc('firstInstall', firstInstall, ctx);
});
const checkIsDoczRepo = assign(ctx => {
  const isDoczRepo = getIsDoczRepo();
  return _assoc('isDoczRepo', isDoczRepo, ctx);
});
const logError = (ctx, ev) => {
  logger__default.fatal(ev.data);
  sh.exit(0);
};

var actions = /*#__PURE__*/Object.freeze({
  ensureFiles: ensureFiles,
  getIsFirstInstall: getIsFirstInstall,
  getIsDoczRepo: getIsDoczRepo,
  assignFirstInstall: assignFirstInstall,
  checkIsDoczRepo: checkIsDoczRepo,
  logError: logError
});

const asyncState = (src, onDoneTarget) => ({
  initial: 'exec',
  states: {
    exec: {
      invoke: {
        src,
        onDone: 'success',
        onError: 'failure'
      }
    },
    success: {
      type: 'final'
    },
    failure: {
      actions: ['logError'],
      type: 'final'
    }
  },
  onDone: {
    target: onDoneTarget || 'exit'
  }
});

const machine = Machine({
  id: 'devServer',
  type: 'parallel',
  states: {
    watch: {
      onEntry: 'ensureFiles',
      invoke: {
        src: 'watchFiles'
      }
    },
    server: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            START_MACHINE: {
              actions: ['assignFirstInstall', 'checkIsDoczRepo'],
              target: 'ensuringDirs'
            }
          }
        },
        ensuringDirs: asyncState('ensureDirs', 'creatingResources'),
        creatingResources: asyncState('createResources', 'executingCommand'),
        executingCommand: asyncState('execDevCommand'),
        exit: {
          type: 'final'
        }
      }
    }
  }
});
const devServerMachine = machine.withConfig({
  services,
  actions
});

const server = args => async () => {
  const doczrcFilepath = await findUp(finds('docz'));
  const machine = devServerMachine.withContext({
    args,
    doczrcFilepath
  });
  const service = interpret(machine).onTransition(state => {
    if (args.debug) {
      console.log(state.value);
    }
  });
  return {
    start: async () => {
      service.start();
      service.send('START_MACHINE');
      process.on('exit', () => {
        service.stop();
      });
    }
  };
};

const spawnSync = (command, args) => {
  const {
    status
  } = spawn$1.sync(command, args, {
    stdio: 'inherit'
  });

  if (status !== 0) {
    process.exitCode = status || 1;
  }
};

const build = async (config, dist) => {
  const publicDir = join(docz, 'public');
  const cliArgs = ['run', 'build'];

  if (typeof config.base === 'string' && config.base.length) {
    cliArgs.push('--'); // Append gatsby option `--prefix-paths`to CLI args which will prepend pathPrefix from gatsby-config to urls
    // https://www.gatsbyjs.org/docs/path-prefix/

    cliArgs.push('--prefix-paths');
  }

  ensureFiles({
    args: config
  });
  sh.cd(docz);
  spawnSync('npm', cliArgs);
  await copy(publicDir, dist);
};

const bundler = args => {
  return new Bundler({
    args,
    build,
    server: server(args)
  });
};

process.setMaxListeners(Infinity);
const dev = async args => {
  copyDoczRc(args.config);
  const config = await parseConfig(args);
  const bundler$1 = bundler(config);
  const app = await bundler$1.createApp();

  try {
    await app.start();
  } catch (err) {
    logger__default.fatal('Failed to process data server');
    logger__default.error(err);
    process.exit(1);
  }
};

process.setMaxListeners(Infinity);
const init = async args => {
  copyDoczRc(args.config);
  const doczrcFilepath = path$1__default.join(docz, 'doczrc.js');
  const config = await parseConfig(args);
  const isFirstInstall = getIsFirstInstall();
  const isDoczRepo = getIsDoczRepo();
  await ensureDirs();
  const serverMachineContext = {
    args: config,
    isDoczRepo,
    firstInstall: isFirstInstall,
    doczrcFilepath
  };
  await createResources(serverMachineContext);
};

const build$1 = async args => {
  copyDoczRc(args.config);
  const config = await parseConfig(args);
  const bundler$1 = bundler(config);

  try {
    await init(args);
  } catch (err) {
    error(`Failed to initialize docz : ${err.message}`);
  }

  try {
    await bundler$1.build();
  } catch (err) {
    error(err);
    process.exit(1);
  }
};

const serve = async args => {
  const config = await parseConfig(args);
  const cliArgs = ['run', 'serve'];

  if (config.port) {
    cliArgs.push('--'); // Append gatsby option `port` to CLI args
    // https://www.gatsbyjs.org/docs/cheat-sheet/#cheat_sheet-text

    cliArgs.push('--port');
    cliArgs.push(String(config.port));
  }

  if (config.host) {
    // Append gatsby option `host` to CLI args
    // https://www.gatsbyjs.org/docs/cheat-sheet/#cheat_sheet-text
    cliArgs.push('--host');
    cliArgs.push(String(config.host));
  }

  sh.cd(docz);
  spawnSync('npm', cliArgs);
};

const cli = () => {
  return command('init', 'initialize docz in your app', setArgs, async args => {
    setEnv('development');
    await init(args);
  }).command('dev', 'initialize docz dev server', setArgs, async args => {
    setEnv('development');
    await dev(args);
  }).command('build', 'build dir as static site', setArgs, async args => {
    setEnv('production');
    await build$1(args);
    process.exit();
  }).command('serve', 'serve dir as static site', setArgs, async args => {
    setEnv('production');
    await serve(args);
    process.exit();
  }).demandCommand().recommendCommands().help().wrap(72).epilog('for more information visit https://github.com/doczjs/docz').showHelpOnFail(false, 'whoops, something went wrong! run with --help').argv;
};

const createId = file => createHash('md5').update(file).digest('hex');

class Entry {
  constructor(ast, file, config) {
    const filepath = this.getFilepath(config, file);
    const parsed = getParsedData(ast);
    const name = this.getName(filepath, parsed);
    const root = getRootDir(config);
    this.id = createId(file);
    this.filepath = filepath;
    this.fullpath = resolve(root, file);
    this.link = '';
    this.hidden = parsed.hidden || false;
    this.slug = this.slugify(filepath, config.separator);
    this.route = this.getRoute(parsed);
    this.name = name;
    this.menu = parsed.menu || '';
    this.headings = headingsFromAst(ast);
    this.settings = parsed;
  }

  setLink(url) {
    this.link = url.replace('{{filepath}}', this.filepath);
  }

  getFilepath(config, file) {
    const root = getRootDir(config);
    const fullpath = resolve(root, config.src, file);
    const filepath = relative(root, fullpath);

    if (process.platform === 'win32') {
      return filepath.split('\\').join('/');
    }

    return filepath;
  }

  getName(filepath, parsed) {
    const filename = humanize(parse(filepath).name);
    return parsed && parsed.name ? parsed.name : filename;
  }

  slugify(filepath, separator) {
    const ext = extname(filepath);
    const fileWithoutExt = filepath.replace(ext, '');
    return slugify(fileWithoutExt, {
      separator
    });
  }

  getRoute(parsed) {
    const parsedRoute = _get('route', parsed);

    return parsedRoute || `/${this.slug}`;
  }

}

const mapToObj = map => Array.from(map.entries()).reduce((obj, [key, value]) => Object.assign({}, obj, {
  [`${key}`]: value
}), {});

const matchFilesWithSrc = config => files => {
  const {
    paths,
    src
  } = config;
  const rootDir = paths.getRootDir(config);
  const srcDir = resolve(rootDir, src);
  const prefix = relative(rootDir, srcDir);
  return files.map(file => file.startsWith(prefix) ? file : join(prefix, file));
};
const getFilesToMatch = config => {
  const {
    files: pattern
  } = config;
  const arr = Array.isArray(pattern) ? pattern : [pattern];
  const toMatch = matchFilesWithSrc(config);
  return toMatch(arr);
};
class Entries {
  constructor(config) {
    this.repoEditUrl = getRepoEditUrl(config);
    this.all = new Map();

    this.get = async () => this.getMap(config);
  }

  async getMap(config) {
    const {
      paths,
      ignore,
      plugins,
      mdPlugins,
      src
    } = config;
    const fileMatchingPatterns = getFilesToMatch(config);
    const srcHasNodeModules = src.indexOf('node_modules') !== -1; // Hack around fast-glob not returning the whole set when many patterns are provided in the array

    let initialFiles = [];

    for (let filePattern of fileMatchingPatterns) {
      const filePatternHasNodeModules = filePattern.indexOf('node_modules') !== -1;
      const shouldIncludeNodeModules = srcHasNodeModules || filePatternHasNodeModules;
      const globIgnore = shouldIncludeNodeModules ? [] : ['**/node_modules/**'];
      const filesFromPattern = await glob([filePattern], {
        cwd: paths.getRootDir(config),
        ignore: globIgnore,
        onlyFiles: true,
        unique: true,
        baseNameMatch: false,
        caseSensitiveMatch: false
      });
      initialFiles = [...initialFiles, ...filesFromPattern];
    }

    const files = initialFiles.filter(value => {
      return !ignore.some(pattern => {
        if (_isString(pattern)) return minimatch(value, pattern);
        if (_isRegExp(pattern)) return pattern.test(value);
        return false;
      });
    });
    const rootDir = paths.getRootDir(config);

    const createEntry = async file => {
      try {
        const fullpath = resolve(rootDir, file);
        const ast = await parseMdx(fullpath, mdPlugins);
        const entry = new Entry(ast, file, config);
        if (this.repoEditUrl) entry.setLink(this.repoEditUrl);

        const {
          settings
        } = entry,
              rest = __rest(entry, ["settings"]);

        return Object.assign({}, settings, rest);
      } catch (err) {
        error(err);
        return null;
      }
    };

    const reduce = Plugin.reduceFromPlugins(plugins);
    const modifiedFiles = reduce('modifyFiles', files);
    const map = new Map();
    const entries = await Promise.all(modifiedFiles.map(createEntry).filter(Boolean));

    for (const entry of entries) {
      if (entry) {
        map.set(entry.filepath, entry);
      }
    }

    this.all = map;
    return mapToObj(map);
  }

}

const mapToArray = (map = []) => Object.entries(map).map(entry => entry && {
  key: entry[0],
  value: entry[1]
}).filter(Boolean);

const updateEntries = entries => async p => {
  const prev = _get('entries', p.getState());

  const map = await entries.get();

  if (map && !equal(prev, map)) {
    p.setState('entries', mapToArray(map));
  }
};

const state$1 = (entries, config, dev) => {
  const ignored = config.watchIgnore || WATCH_IGNORE;
  const watcher = chokidar.watch(getFilesToMatch(config), {
    ignored,
    persistent: true,
    cwd: getRootDir(config)
  });
  watcher.setMaxListeners(Infinity);
  return {
    id: 'entries',
    start: async params => {
      const update = updateEntries(entries);
      await update(params);

      if (dev) {
        watcher.on('add', async () => update(params));
        watcher.on('change', async () => update(params));
        watcher.on('unlink', async () => update(params));
        watcher.on('raw', async (event, path, details) => {
          if (details.event === 'moved' && details.type === 'directory') {
            await update(params);
          }
        });
      }
    },
    close: () => {
      watcher.close();
    }
  };
};

// Based on https://github.com/reactjs/react-docgen/issues/256#issuecomment-417352843
const {
  default: resolveHOC
} = require('react-docgen/dist/utils/resolveHOC');

const {
  default: resolveToModule
} = require('react-docgen/dist/utils/resolveToModule');

const {
  utils,
  resolver: reactDocgenResolver
} = require('react-docgen');

const createStyledComponentResolvers = () => {
  const moduleName = 'styled-components';

  const isStyledExpression = (tagPath, t) => t.CallExpression.check(tagPath.node) && tagPath.get('callee').node.name === 'styled' || t.MemberExpression.check(tagPath.node) && tagPath.get('object').node.name === 'styled';

  function isStyledComponent(def, t) {
    if (!t.TaggedTemplateExpression.check(def.node) || !isStyledExpression(def.get('tag'), t)) {
      return false;
    }

    const module = resolveToModule(def.get('tag'));
    return !!module && module === moduleName;
  }

  const exportTagged = (path, t) => {
    const definitions = utils.resolveExportDeclaration(path, t);
    const components = [];
    definitions.filter(Boolean).forEach(def => {
      let comp = def;

      if (isStyledComponent(comp, t)) {
        components.push(comp);
      } else {
        comp = utils.resolveToValue(resolveHOC(comp));
        if (isStyledComponent(comp, t)) components.push(comp);
      }
    });
    return components;
  };

  function findExportedStyledComponent(ast, recast) {
    const components = [];
    const t = recast.types.namedTypes;

    const visitor = path => {
      components.push(...exportTagged(path, t));
      return false;
    };

    recast.visit(ast, {
      visitFunctionDeclaration: false,
      visitFunctionExpression: false,
      visitClassDeclaration: false,
      visitClassExpression: false,
      visitIfStatement: false,
      visitWithStatement: false,
      visitSwitchStatement: false,
      visitCatchCause: false,
      visitWhileStatement: false,
      visitDoWhileStatement: false,
      visitForStatement: false,
      visitForInStatement: false,
      visitExportDefaultDeclaration: visitor
    });
    return components;
  }

  function findAllExportedStyledComponents(ast, recast) {
    const components = [];
    const t = recast.types.namedTypes;

    const visitor = path => {
      components.push(...exportTagged(path, t));
      return false;
    };

    recast.visit(ast, {
      visitFunctionDeclaration: false,
      visitFunctionExpression: false,
      visitClassDeclaration: false,
      visitClassExpression: false,
      visitIfStatement: false,
      visitWithStatement: false,
      visitSwitchStatement: false,
      visitCatchCause: false,
      visitWhileStatement: false,
      visitDoWhileStatement: false,
      visitForStatement: false,
      visitForInStatement: false,
      visitExportDeclaration: visitor,
      visitExportNamedDeclaration: visitor,
      visitExportDefaultDeclaration: visitor
    });
    return components;
  }

  function findAllStyledComponents(ast, recast) {
    const components = [];
    const t = recast.types.namedTypes;
    recast.visit(ast, {
      visitFunctionDeclaration: false,
      visitFunctionExpression: false,
      visitClassDeclaration: false,
      visitClassExpression: false,
      visitIfStatement: false,
      visitWithStatement: false,
      visitSwitchStatement: false,
      visitCatchCause: false,
      visitWhileStatement: false,
      visitDoWhileStatement: false,
      visitForStatement: false,
      visitForInStatement: false,

      visitTaggedTemplateExpression(path) {
        let comp = path;

        if (isStyledComponent(path, t)) {
          components.push(path);
        } else {
          comp = utils.resolveToValue(resolveHOC(path));
          if (isStyledComponent(comp, t)) components.push(comp);
        }

        return false;
      }

    });
    return components;
  }

  return {
    findAllStyledComponents,
    findAllExportedStyledComponents,
    findExportedStyledComponent
  };
};
const resolver = (ast, recast) => [...reactDocgenResolver.findAllExportedComponentDefinitions(ast, recast), ...createStyledComponentResolvers().findAllExportedStyledComponents(ast, recast)];

// vendored from react-docgen-external-proptypes-handler
// which is not well maintained
// https://github.com/doczjs/docz/issues/727
const path = require('path');

const fs = require('fs');

const recast = require('recast');
/**
 * Re-using few private methods of react-docgen to avoid code duplication
 */


const isRequiredPropType = require('react-docgen/dist/utils/isRequiredPropType').default;

const setPropDescription = require('react-docgen/dist/utils/setPropDescription').default;

let babylon;

try {
  const buildParser = require('react-docgen/dist/babelParser').default;

  babylon = buildParser();
} catch (e) {
  /** DOCZ: special error message as people often encounter errors here because they misconfigure or lack a babel plugin */
  console.error('Error while initializing babel in docz: ', e);
  /** DOCZ: disabling this require because it no longer exists */

  throw new Error(e); // babylon = require('react-docgen/dist/babylon').default
}

const utils$1 = require('react-docgen').utils;

const types = recast.types.namedTypes;
const HOP = Object.prototype.hasOwnProperty;
const createObject = Object.create;

function isPropTypesExpression(path) {
  const moduleName = utils$1.resolveToModule(path);

  if (moduleName) {
    return utils$1.isReactModuleName(moduleName) || moduleName === 'ReactPropTypes';
  }

  return false;
}
/**
 * Amends the documentation object with propTypes information.
 * @method amendPropTypes
 * @param  {Object} documentation  documentation object
 * @param  {Object} path  node path reference of propTypes property
 */


function amendPropTypes(documentation, path) {
  if (!types.ObjectExpression.check(path.node)) {
    return;
  }

  path.get('properties').each(propertyPath => {
    let propDescriptor, valuePath, type, resolvedValuePath;
    const nodeType = propertyPath.node.type;

    if (nodeType === types.Property.name) {
      propDescriptor = documentation.getPropDescriptor(utils$1.getPropertyName(propertyPath));
      valuePath = propertyPath.get('value');
      type = isPropTypesExpression(valuePath) ? utils$1.getPropType(valuePath) : {
        name: 'custom',
        raw: utils$1.printValue(valuePath)
      };

      if (type) {
        propDescriptor.type = type;
        propDescriptor.required = type.name !== 'custom' && isRequiredPropType(valuePath);
      }
    } else if (nodeType === types.SpreadProperty.name) {
      resolvedValuePath = utils$1.resolveToValue(propertyPath.get('argument')); // normal object literal

      if (resolvedValuePath.node.type === types.ObjectExpression.name) {
        amendPropTypes(documentation, resolvedValuePath);
      }
    }

    if (types.Property.check(propertyPath.node)) {
      setPropDescription(documentation, propertyPath);
    }
  });
}
/**
 * Accepts absolute path of a source file and returns the file source as string.
 * @method getSrc
 * @param  {String} filePath  File path of the component
 * @return {String} Source code of the given file if file exist else returns empty
 */


function getSrc(filePath) {
  let src;

  if (fs.existsSync(filePath)) {
    src = fs.readFileSync(filePath, 'utf-8');
  }

  return src;
}

function getAST(src) {
  return recast.parse(src, {
    source: 'module',
    esprima: babylon
  });
}
/**
 * Resolves propTypes source file path relative to current component,
 * which resolves only file extension of type .js or .jsx
 *
 * @method resolveFilePath
 * @param  {String} componentPath  Relative file path of the component
 * @param  {String} importedFilePath Relative file path of a dependent component
 * @return {String} Resolved file path if file exist else null
 */


function resolveFilePath(componentPath, importedFilePath) {
  const regEx = /\.(js|jsx)$/;
  let srcPath = path.resolve(path.dirname(componentPath), importedFilePath);

  if (regEx.exec(srcPath)) {
    return srcPath;
  } else {
    srcPath += fs.existsSync(`${srcPath}.js`) ? '.js' : '.jsx';
    return srcPath;
  }
}
/**
 * Method which returns actual values from the AST node of type specifiers.
 *
 * @method getSpecifiersOfNode
 */


function getSpecifiersOfNode(specifiers) {
  const specifier = [];
  specifiers.forEach(node => {
    specifier.push(node.local.name);
  });
  return specifier;
}
/**
 * Filters the list of identifier node values or node paths from a given AST.
 *
 * @method getIdentifiers
 * @param  {Object} ast Root AST node of a component
 * @return {Object} Which holds identifier relative file path as `key` and identifier name as `value`
 */


function getIdentifiers(ast) {
  const identifiers = createObject(null);
  recast.visit(ast, {
    visitVariableDeclarator(path) {
      const node = path.node;
      const nodeType = node.init.type;

      if (nodeType === types.Identifier.name) {
        if (identifiers[node.init.name]) {
          identifiers[node.init.name].push(node.init.name);
        } else {
          identifiers[node.init.name] = [node.init.name];
        }
      } else if (nodeType === types.Literal.name) {
        if (identifiers[node.id.name]) {
          identifiers[node.id.name].push(node.init.value);
        } else {
          identifiers[node.id.name] = [node.init.value];
        }
      } else if (nodeType === types.ArrayExpression.name) {
        if (identifiers[node.id.name]) {
          identifiers[node.id.name].push(node.init.elements);
        } else {
          identifiers[node.id.name] = node.init.elements;
        }
      } else if (nodeType === types.ObjectExpression.name) {
        if (identifiers[node.id.name]) {
          identifiers[node.id.name].push({
            path,
            value: node.init.properties
          });
        } else {
          identifiers[node.id.name] = {
            path,
            value: node.init.properties
          };
        }
      }

      this.traverse(path);
    }

  });
  return identifiers;
}
/**
 * Traverse through given AST and filters named and default export declarations.
 *
 * @method getExports
 * @param  {Object} ast Root AST node of a component
 * @return {Array} which holds list of named identifiers
 */


function getExports(ast) {
  const exports = [];
  recast.visit(ast, {
    visitExportNamedDeclaration(path) {
      const node = path.node;
      const specifiers = getSpecifiersOfNode(node.specifiers);
      const declarations = Object.keys(getIdentifiers(ast));
      exports.push(...new Set(specifiers.concat(declarations)));
      this.traverse(path);
    },

    visitExportDefaultDeclaration(path) {
      const node = path.node;

      if (node.declaration.type === types.Identifier.name) {
        exports.push(node.declaration.name);
      }
      /* Commenting it for now, this might needed for further enhancements.
      else if (nodeType === types.Literal.name) {
        varDeclarators.push(node.init.value);
      } else if (nodeType === types.ArrayExpression.name) {
        computedPropNodes[node.id.name] = node.init.elements;
      }*/


      this.traverse(path);
    }

  });
  return exports;
}
/**
 * Method to list all specifiers of es6 `import` of a given file(AST)
 *
 * @method getImports
 * @param  {Object} ast Root AST node of a component
 * @return {Object/Boolean} if Object: Holds import module name or file path as `key`
 *                          and identifier as `value`, else return false
 */


function getImports(ast) {
  const specifiers = createObject(null);
  recast.visit(ast, {
    visitImportDeclaration: path => {
      const name = path.node.source.value;
      const specifier = getSpecifiersOfNode(path.node.specifiers);

      if (!specifiers[name]) {
        specifiers[name] = specifier;
      } else {
        specifiers[name].push(...specifier);
      }

      return false;
    }
  });
  return specifiers;
}
/**
 * Method to resolve all dependent values(computed values, which are from external files).
 *
 * @method resolveImportedDependencies
 * @param  {Object} ast Root AST node of the component
 * @param  {Object} srcFilePath Absolute path of a dependent file
 * @return {Object} Holds export identifier as `key` and respective AST node path as value
 */


function resolveImportedDependencies(ast, srcFilePath) {
  const filteredItems = createObject(null);
  const importSpecifiers = getImports(ast);
  let identifiers, resolvedNodes;

  if (importSpecifiers && Object.keys(importSpecifiers).length) {
    resolvedNodes = resolveDependencies(importSpecifiers, srcFilePath);
  }

  const exportSpecifiers = getExports(ast);

  if (exportSpecifiers && exportSpecifiers.length) {
    identifiers = getIdentifiers(ast);
  }

  if (resolvedNodes) {
    Object.assign(identifiers, ...resolvedNodes);
  }

  for (const identifier in identifiers) {
    if (HOP.call(identifiers, identifier) && exportSpecifiers.indexOf(identifier) > -1) {
      filteredItems[identifier] = identifiers[identifier];
    }
  }

  return filteredItems;
}
/**
 * Method to resolve all the external dependencies of the component propTypes
 *
 * @method resolveDependencies
 * @param  {Array} filePaths List of files to resolve
 * @param  {String} componentPath Absolute path of the component in case `propTypes` are declared in a component file or
 *                  absolute path to the file where `propTypes` is declared.
 */


function resolveDependencies(filePaths, componentPath) {
  const importedNodes = [];

  for (const importedFilePath in filePaths) {
    if (HOP.call(filePaths, importedFilePath)) {
      const srcPath = resolveFilePath(componentPath, importedFilePath);

      if (!srcPath) {
        return;
      }

      const src = getSrc(srcPath);

      if (src) {
        const ast = getAST(src);
        importedNodes.push(resolveImportedDependencies(ast, srcPath));
      }
    }
  }

  return importedNodes;
}
/**
 * Method to filter computed props(which are declared out side of the component and used in propTypes object).
 *
 * @method filterSpecifiers
 * @param  {Object} specifiers  List which holds all the values of external dependencies
 * @return {Object} computedPropNames  List which holds all the computed values from `propTypes` property
 */


function filterSpecifiers(specifiers, computedPropNames) {
  const filteredSpecifiers = createObject(null);

  for (const cp in computedPropNames) {
    if (HOP.call(computedPropNames, cp)) {
      for (const sp in specifiers) {
        if (HOP.call(specifiers, sp) && specifiers[sp].indexOf(cp) > -1) {
          if (filteredSpecifiers[sp]) {
            filteredSpecifiers[sp].push(cp);
          } else {
            filteredSpecifiers[sp] = [cp];
          }
        }
      }
    }
  }

  return filteredSpecifiers;
}
/**
 * Method to parse and get computed nodes from a document object
 *
 * @method getComputedPropValuesFromDoc
 * @param  {Object} doc  react-docgen document object
 * @return {Object/Boolean} Object with computed property identifer as `key` and AST node path as `value`,
 *                          If document object have any computed properties else return false.
 */


function getComputedPropValuesFromDoc(doc) {
  let flag;
  const computedProps = createObject(null);
  const props = doc.toObject().props;
  flag = false;

  if (props) {
    for (const prop in props) {
      if (HOP.call(props, prop)) {
        const o = props[prop];

        if (o.type && o.type.name === 'enum' && o.type.computed) {
          flag = true;
          computedProps[o.type.value] = o;
        }
      }
    }

    return flag ? computedProps : false;
  } else {
    return false;
  }
}
/**
 * Method to update the document object computed values with actual values to generate doc for external dependent values.
 *
 * @method amendDocs
 * @param  {Object} doc  react-docgen document object
 * @param  {Object} path  AST node path of component `propTypes`
 * @param  {Object} props  list of actual values of computed properties
 */


function amendDocs(doc, path, props) {
  const propsToPatch = path.get('properties');

  function getComputedPropVal(name) {
    for (let i = 0; i < props.length; i++) {
      if (props[i][name]) {
        return props[i][name];
      }
    }
  }

  propsToPatch.each(propertyPath => {
    const propDescriptor = doc.getPropDescriptor(utils$1.getPropertyName(propertyPath));

    if (propDescriptor.type.name === 'enum' && propDescriptor.type.computed) {
      const oldVal = propDescriptor.type.value;
      const newVal = getComputedPropVal(propDescriptor.type.value) || oldVal;
      propDescriptor.type.value = newVal;
      propDescriptor.type.computed = false;
    }
  });
}
/**
 * Initializer of react-docgen custom handler.
 *
 * @method externalProptypesHandler
 * @param  {String} componentPath  Absolute path of the react component
 */


function externalProptypesHandler(componentPath) {
  return (doc, path) => {
    const root = path.scope.getGlobalScope().node;
    let propTypesPath, propTypesFilePath, propTypesAST;
    propTypesPath = utils$1.getMemberValuePath(path, 'propTypes');
    propTypesAST = root;
    propTypesFilePath = componentPath;

    if (!propTypesPath) {
      return;
    }

    const propsNameIdentifier = propTypesPath.node.name;
    propTypesPath = utils$1.resolveToValue(propTypesPath);

    if (!propTypesPath) {
      return;
    }

    if (!types.ObjectExpression.check(propTypesPath.node)) {
      //First resolve dependencies against component path
      propTypesFilePath = resolveFilePath(componentPath, propTypesPath.node.source.value);
      const propTypesSrc = getSrc(propTypesFilePath);
      propTypesAST = getAST(propTypesSrc);
      const importedPropTypes = getIdentifiers(propTypesAST)[propsNameIdentifier];

      if (!importedPropTypes) {
        return;
      }

      propTypesPath = utils$1.resolveToValue(importedPropTypes.path); //updating doc object with external props

      amendPropTypes(doc, propTypesPath);
    }

    const computedPropNames = getComputedPropValuesFromDoc(doc);

    if (!computedPropNames) {
      return;
    }

    const importSpecifiers = getImports(propTypesAST);

    if (!importSpecifiers) {
      return;
    }

    const filteredProps = filterSpecifiers(importSpecifiers, computedPropNames);

    if (!Object.keys(filteredProps).length) {
      return;
    }

    const resolvedImports = resolveDependencies(filteredProps, propTypesFilePath);

    if (resolvedImports && !resolvedImports.length) {
      return;
    }

    amendDocs(doc, propTypesPath, resolvedImports);
  };
}

const throwError = err => {
  logger__default.fatal(`Error parsing static types`);
  logger__default.error(err);
};

const jsParser = (files, config) => {
  const resolver$1 = config.docgenConfig.resolver || resolver;
  const root = getRootDir(config);

  const parseFilepathProps = filepath => {
    const fullpath = resolve(root, filepath);
    const handlers = defaultHandlers.concat([externalProptypesHandler(filepath), actualNameHandler]);

    try {
      const code = readFileSync(fullpath, {
        encoding: 'utf-8'
      });
      const props = parse$1(code, resolver$1, handlers);
      return {
        key: unixPath(filepath),
        value: props
      };
    } catch (err) {
      if (config.debug) throwError(err);
      return null;
    }
  };

  return files.map(parseFilepathProps).filter(Boolean);
};

const digest = str => createHash('md5').update(str).digest('hex');

const cacheFilepath = join(cache, 'propsParser.json');
const readCacheFile = () => readJSONSync(cacheFilepath, {
  throws: false
});

function checkFilesOnCache(files, config) {
  const cache = readCacheFile();
  const root = getRootDir(config);
  if (_isEmpty(cache)) return files;
  return files.filter(filepath => {
    const normalized = normalize(filepath);
    const fullpath = resolve(root, normalized);
    const hash = digest(readFileSync(fullpath, 'utf-8'));

    const found = _get(normalized, cache);

    return found && hash !== found.hash;
  });
}

function writePropsOnCache(items, config) {
  const cache = readCacheFile();
  const root = getRootDir(config);
  const newCache = items.reduce((obj, {
    key: filepath,
    value
  }) => {
    const fullpath = resolve(root, normalize(filepath));
    const hash = digest(readFileSync(fullpath, 'utf-8'));
    return Object.assign({}, obj, {
      [unixPath(filepath)]: {
        hash,
        props: value
      }
    });
  }, {});
  outputJSONSync(cacheFilepath, Object.assign({}, cache, newCache));
}

function getPropsOnCache() {
  const cache = readCacheFile();

  if (_isEmpty(cache)) {
    warn('No cache was found with your props definitions');
    warn("We'll parse your components to get props from them");
    warn('Depending on your components, this could take while...');
    return [];
  }

  return Object.entries(cache).map(([key, value]) => ({
    key: unixPath(key),
    value: _get('props', value)
  }));
}

const mergeWithCache = (cache, props) => {
  const keys = props.map(_prop('key'));
  return cache.filter(item => !_contains(item.key, keys)).concat(props);
};

const removeFromCache = filepath => {
  const cache = readCacheFile();
  outputJSONSync(cacheFilepath, _omit(filepath, cache));
};

const getInitialFilesMap = () => {
  const cache = readCacheFile();
  if (_isEmpty(cache)) return new Map();
  const map = new Map();

  _entries(cache).forEach(([filepath]) => {
    const exist = pathExistsSync(filepath);

    if (!exist) {
      removeFromCache(filepath);
    } else {
      map.set(filepath, {
        text: readFileSync(filepath, 'utf-8'),
        version: 0
      });
    }
  });

  return map;
};

let languageService = null;
const filesMap = getInitialFilesMap();

function getTSConfigFile(tsconfigPath) {
  const basePath = dirname(tsconfigPath);
  const configFile = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
  return ts.parseJsonConfigFileContent(configFile.config, ts.sys, basePath, {}, tsconfigPath);
}

function loadFiles(filesToLoad, config) {
  const root = getRootDir(config);
  filesToLoad.forEach(filepath => {
    const normalized = normalize(filepath);
    const fullpath = resolve(root, normalized);
    const found = filesMap.get(normalized);
    filesMap.set(normalized, {
      text: readFileSync(fullpath, 'utf-8'),
      version: found ? found.version + 1 : 0
    });
  });
}

function createServiceHost(compilerOptions, files, config) {
  const root = getRootDir(config);
  return {
    getScriptFileNames: () => {
      return [...files.keys()];
    },
    getScriptVersion: fileName => {
      const file = files.get(fileName);
      return file && file.version.toString() || '';
    },
    getScriptSnapshot: fileName => {
      const fullpath = resolve(root, fileName);

      if (!existsSync(fullpath)) {
        return undefined;
      }

      let file = files.get(fileName);

      if (file === undefined) {
        const text = readFileSync(fullpath).toString();
        file = {
          version: 0,
          text
        };
        files.set(fileName, file);
      }

      return ts.ScriptSnapshot.fromString(file.text);
    },
    getCurrentDirectory: () => root,
    getCompilationSettings: () => compilerOptions,
    getDefaultLibFileName: options => ts.getDefaultLibFilePath(options),
    fileExists: ts.sys.fileExists,
    readFile: ts.sys.readFile,
    readDirectory: ts.sys.readDirectory
  };
}

const defaultPropFilter = prop => {
  return prop.parent == null || !prop.parent.fileName.includes('node_modules');
};

const parseFiles = (files, config, tsconfig) => {
  const opts = {
    propFilter(prop) {
      const customPropFilter = config.docgenConfig.propFilter;
      const propFilter = customPropFilter && _isFunction(customPropFilter) ? customPropFilter : defaultPropFilter;
      return Boolean(propFilter(prop));
    },

    componentNameResolver(exp, source) {
      const componentNameResolver = config.docgenConfig.resolver;
      const val = componentNameResolver && _isFunction(componentNameResolver) && componentNameResolver(exp, source);
      return val;
    }

  };
  loadFiles(files, config);
  const parser = withCustomConfig(tsconfig, opts);

  const compilerOptions = _get('options', getTSConfigFile(tsconfig));

  const programProvider = () => {
    if (languageService) return languageService.getProgram();
    const servicesHost = createServiceHost(compilerOptions, filesMap, config);
    const documentRegistry = ts.createDocumentRegistry();
    languageService = ts.createLanguageService(servicesHost, documentRegistry);
    return languageService.getProgram();
  };

  return files.map(filepath => ({
    key: unixPath(filepath),
    value: parser.parseWithProgramProvider(filepath, programProvider)
  }));
};

const tsParser = (files, config, tsconfig) => {
  if (!tsconfig) return [];
  const filesToLoad = checkFilesOnCache(files, config);
  const propsOnCache = getPropsOnCache();
  if (!filesToLoad.length) return propsOnCache;
  const next = parseFiles(filesToLoad, config, tsconfig);
  writePropsOnCache(next, config);
  return mergeWithCache(propsOnCache, next);
};

const unixPath = src => {
  return normalize(src).replace(/\\/g, '/');
};
const docgen = async (files, config) => {
  const cwd = getRootDir(config);
  const tsconfig = await findUp('tsconfig.json', {
    cwd
  });
  const tsFiles = files.filter(file => file.match(/\.(tsx|ts)$/));
  const jsFiles = files.filter(file => file.match(/\.(js|jsx|mjs)$/));
  return config.typescript ? tsParser(tsFiles, config, tsconfig).concat(jsParser(jsFiles, config)) : jsParser(jsFiles, config);
};

const getPattern = config => {
  const {
    ignore,
    src: source,
    typescript: ts,
    docgenConfig: docgenConfig
  } = config;

  if (docgenConfig.searchPatterns) {
    return docgenConfig.searchPatterns;
  }

  const searchPath = docgenConfig.searchPath ? docgenConfig.searchPath : source;
  const root = getRootDir(config);
  const srcDir = resolve(root, searchPath);
  const src = relative(root, srcDir);
  const filesPattern = join(src, ts ? '**/*.{ts,tsx,js,jsx,mjs}' : '**/*.{js,jsx,mjs}');
  return ignore.map(entry => typeof entry === 'string' && `!**/${entry}`).filter(Boolean).concat([unixPath(filesPattern), '!**/node_modules', '!**/doczrc.js']);
};

const removeFilepath = (items, filepath) => items.filter(item => item.key !== filepath);

const initial = (config, pattern) => async p => {
  const {
    filterComponents
  } = config;
  const cwd = getRootDir(config);
  const files = await glob(pattern, {
    cwd,
    caseSensitiveMatch: false
  });
  const filtered = filterComponents ? filterComponents(files) : files;
  const metadata = await docgen(filtered, config);
  p.setState('props', metadata);
};

const change = (p, config) => async filepath => {
  const prev = _get('props', p.getState());

  const metadata = await docgen([filepath], config);
  const filtered = metadata.filter(_propEq('key', filepath));
  const next = removeFilepath(prev, filepath).concat(filtered);
  p.setState('props', next);
};

const remove = p => async filepath => {
  const prev = _get('props', p.getState());

  const next = removeFilepath(prev, filepath);
  p.setState('props', next);
};

const state$2 = (config, dev) => {
  const pattern = getPattern(config);
  const ignored = config.watchIgnore || WATCH_IGNORE;
  const cwd = getRootDir(config);
  const watcher = chokidar.watch(pattern, {
    cwd,
    ignored,
    persistent: true
  });
  watcher.setMaxListeners(Infinity);
  return {
    id: 'props',
    start: async params => {
      const addInitial = initial(config, pattern);
      await addInitial(params);

      if (dev) {
        watcher.on('change', change(params, config));
        watcher.on('unlink', remove(params));
      }
    },
    close: () => {
      watcher.close();
    }
  };
};



var index = /*#__PURE__*/Object.freeze({
  entries: state$1,
  config: state,
  props: state$2
});

class DataServer {
  constructor() {
    this.states = new Set();
    this.state = new Map();
    this.listeners = new Set();
  }

  register(states) {
    for (const state of states) this.states.add(state);

    return this;
  }

  async start() {
    const setState = (key, val) => this.setState(key, val);

    const getState = () => this.getState();

    await Promise.all(Array.from(this.states).map(async state => {
      if (!_isFunction(state.start)) return;
      return state.start({
        setState,
        getState
      });
    }));
  }

  close() {
    for (const state of this.states) {
      if (_isFunction(state.close)) {
        state.close();
      }
    }
  }

  onStateChange(listener) {
    this.listeners.add(listener);
    return () => this.listeners.clear();
  }

  getState() {
    return this.mapToObject(this.state);
  }

  setState(key, val) {
    const prev = _get(key, this.getState());

    const next = typeof val === 'function' ? val(prev) : val;
    this.state.set(key, next);
    this.writeDbFile();
    this.listeners.forEach(listener => {
      listener({
        type: `state.${key}`,
        payload: next
      });
    });
  }

  async writeDbFile() {
    outputJSONSync(db, this.mapToObject(this.state), {
      spaces: 2
    });
  }

  mapToObject(map) {
    return Array.from(map.entries()).reduce((obj, [key, val]) => Object.assign({}, obj, {
      [key]: val
    }), {});
  }

}

export { DataServer, Entries, Entry, Plugin, cli, createPlugin, getBaseConfig, parseConfig, setArgs, index as states };
